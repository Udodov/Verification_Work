# Итоговая проверочная работа студента **GeekBrains**
## `Удодов Константин`, программа "Разработчик" 
###  [https://gb.ru/users/2446468]("Удодов К.В.")
---
Для полценного выполнения проверочной работы необходимо:

1. Создать репозиторий на GitHub
2. Нарисовать блок-схему алгоритма (можно обойтись блок-схемой основной содержательной части, если вы выделяете ее в отдельный метод)
3. Снабдить репозиторий оформленным текстовым описанием решения (файл README.md)
4. Написать программу, решающую поставленную задачу
5. Использовать контроль версий в работе над этим небольшим проектом (не должно быть так что все залито одним коммитом, как минимум этапы 2, 3 и 4 должны быть расположены в разных коммитах)
---
*Условие задачи:*

     Написать программу, которая из имеющегося массива строк формирует массив из строк, длина которых меньше либо равна 3 символа. Первоначальный массив можно ввести с клавиатуры, либо задать на старте выполнения алгоритма. При решении не рекомендуется пользоваться коллекциями, лучше обойтись исключительно массивами.

*Примеры*:

["hello", "2", "world", ":-)"] -> ["2", ":-)"]

["1234", "1567", "-2", "computer science"] -> ["-2"]

["Russia", "Denmark", "Kazan"] -> []

---
РЕШЕНИЕ ЗАДАЧИ:
При решении данной задачи я ипользовал оба варианта задания первоначального массива 

(1. Вводится с клавиатуры. 2. Задается на старте выполнения алгоритма.)

---

>>Решение 1. **Первоначальный массив задаётся на старте выполнения алгоритма.**

1. Объявляется два одномерных строковых массива. Первоначальный задается на старте алгоритма. Новый имеет такую же длину (такой же размер).
2. В решении использовал несколько функций:  `PrintArray(arr[ ])` - для вывода массива на консоль, `SelectedArray(arr[ ])` - для формирования элементов нового массива, удовлетворяющих условию (длина <=3).
gth3. В методе `SelectedArray(arr[ ])` используется цикл переборки элементов массива с проверкой условия, в котором проверяется условие, что длина значения элемента ≤3. При выполнении условия, значение данного элемента записывается в ячейку элемента нового массива.

 >(Примечание: Если важно, чтобы индексы элементов в новом массиве шли по порядку, необходимо объявить дополнительную переменную типа данных `int`. Которой внутри цикла, при выполнении условия будет присваиваться индекс элемента нового массива, а значение элемента первоначального массива присваивается значению в новом массиве с индексом этой переменной. После присвоения переменная увеличивается инкрементом (на 1) и возвращаемся в цикл перебора начального массива. Таким образом, в новом массиве значения элементов будут выводиться с индексами по порядку.)
 ---
 >>Решение 2. **Первоначальный массив вводится с клавиатуры.**

1. Объявляется переменная с типом `int`.
2. На консоль выводится запрос пользователю ввести число для желаемого количество элементов в массиве (задается длина массива). С проверкой на корректность ввода числа (что пользователь действительно ввел целое положительное число, в противном случае предлагается повторить ввод)
3. Объявляется два одномерных строковых массива с одинаковой длиной (введенной с клавиатуры)
4. В решении использовал несколько функций:  `FillArray(arr[ ])` - для заполнения массива с клавиатуры, `PrintArray(arr[ ])` - для вывода массива на консоль, `SelectedArray(arr[ ])` - для формирования элементов нового массива, удовлетворяющих условию (длина <=3).
5. В методе `SelectedArray(arr[ ])` используется цикл переборки элементов массива с проверкой условия, в котором проверяется условие, что длина значения элемента ≤3. При выполнении условия, значение данного элемента записывается в ячейку элемента нового массива.

> (Примечание: Если важно, чтобы индексы элементов в новом массиве шли по порядку, необходимо объявить дополнительную переменную типа данных `int`. Которой внутри цикла, при выполнении условия будет присваиваться индекс элемента нового массива, а значение элемента первоначального массива присваивается значению в новом массиве с индексом этой переменной. После присвоения переменная увеличивается инкрементом (на 1) и возвращаемся в цикл перебора начального массива. Таким образом, в новом массиве значения элементов будут выводиться с индексами по порядку.)
---
### Блок-схемы описаны для обоих вариантов решения. 
### Конечный файл с **решением №2.** Для промотра или выбора **решения №1** необходимо перейти с коммитам:

>  commit 34ff5d37defee1ffa56ab9f19190293e054e9dae (Merge branch 'Solution1’) окончательное решение №1

>   (combining all solutions into the main project) - общее решение с закомментированным решением №1) окончательное решение 2 с комментарием решения 1

> ветка Solution1- с решением 1

> ветка Solution2- с решением 2

>  
 (solution 2 was abandoned by deleting the comment with solution 1) окончательное решение №2

##### Также в проект добавлен файл `.gitignore` со впомогательными папками проекта